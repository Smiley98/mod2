How does vector remove work?
Vector guarentees that all elements are contiguous in memory, so that should imply that remove works exactly the same as my memory manager.

Only problem is that we need operations to be templated. By making m2MemoryManager a static class, we can do stuff like m2MemoryManager<T>::remove(component); meaning we don't alias the instance by name but rather by type. Only drawback is that anything that now a lot of things can access m2MemoryManager which is unsafe, and makes it hard to understand lifetimes & where it is actually used.

We can get around this limitation by making a list of all component containers who's indices map to Component::getType()!

Despite adding another layer to memory access, its really not bad cause I think static memory isn't very good to access either so yeah it will be okay to be like ResourceManager->components[T::getType()]. However, I'm not entirely sure how caching will work. Will nothing but components<T> be fetched, or will it fetch a few component<T>s and a few component<U>s? 

For resource management, only store resources worth storing! When the time comes, the user will have the option of either storing a resource that is local to the scene, or shared (persistent, manual control). Again, might be best to put expensive resources all in one place because now we don't have to bounce between two locations. If we really want more control, perhaps restrict access based on scene ie splash screen is only visible to startup and credits. Moreover, delete resources based on the category for maximum memory requirements ie if an allocation fails, delete the splash screen, then some ui, then some accessories, then either keep deleting till the game is unplayable, or tell the user that there's no more memory once the delete sequence has reached core/frequent main loop assets.